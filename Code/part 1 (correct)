#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

#define LCD_ADDR 0x27
#define BL 0x08
#define EN 0x04
#define RS 0x01

LiquidCrystal_I2C lcd(LCD_ADDR, 16, 2);

const TickType_t ledTaskExecutionTime = 500 / portTICK_PERIOD_MS;
const TickType_t counterTaskExecutionTime = 2000 / portTICK_PERIOD_MS;
const TickType_t alphabetTaskExecutionTime = 13000 / portTICK_PERIOD_MS;

volatile TickType_t remainingLedTime = ledTaskExecutionTime;
volatile TickType_t remainingCounterTime = counterTaskExecutionTime;
volatile TickType_t remainingAlphabetTime = alphabetTaskExecutionTime;

TaskHandle_t ledTaskHandle = NULL;
TaskHandle_t counterTaskHandle = NULL;
TaskHandle_t alphabetTaskHandle = NULL;

const int ledPin = 1;
int currentCount = 1;
char currentChar = 'A';

// Flags to track if task has run this cycle
bool ledRan = false;
bool counterRan = false;
bool alphabetRan = false;

static inline void i2cW(uint8_t b) {
  Wire.beginTransmission(LCD_ADDR);
  Wire.write(b);
  Wire.endTransmission();
}
static inline void wr(uint8_t v, bool d) {
  uint8_t base = BL | (d ? RS : 0);
  uint8_t upper = base | (v & 0xF0);
  i2cW(upper | EN);
  i2cW(upper);
  uint8_t lower = base | ((v << 4) & 0xF0);
  i2cW(lower | EN);
  i2cW(lower);
}

void lcdInit() {
  lcd.init();
  delay(2);
  i2cW(BL); // turn on backlight
  wr(0x01, false); // clear screen
  delay(2);
  wr(0x80, false); //set cursor to top right of screen
}

void lcdPrint(const String& s) {
  wr(0x01, false); // clear screen
  delay(5);
  wr(0x80, false); //set cursor to top right of screen
  for (int i=0; i < s.length() && i < 16; i++) {
    wr((uint8_t)s[i], true);
  }
  if (s.length() > 16) {
    wr(0xC0, false); // move to start of second line
    for (int i=16; i < s.length() && i < 32; i++) {
      wr((uint8_t)s[i], true);
    }
  }
}

void ledTask(void* arg) {
  bool state = false;
  pinMode(ledPin, OUTPUT);  
  digitalWrite(ledPin, LOW); //turn off pin

  while (1) {
    // Toggle LED
    state = !state;
    digitalWrite(ledPin, state ? HIGH : LOW);

    // Decrease remaining time
    if (remainingLedTime > 0) {
      remainingLedTime = (remainingLedTime > 500) ? (remainingLedTime - 500) : 0;
    }

    // Suspend self after running once
    ledRan = true;
    vTaskSuspend(NULL); // suspend self until scheduler resumes

  }
}

void counterTask(void* arg) {
  while (1) {
    char buf[32];
    snprintf(buf, sizeof(buf), "Count: %d", currentCount);
    lcdPrint(String(buf));

    currentCount++;
    if (currentCount > 20)
      currentCount = 1;

    if (remainingCounterTime > 0) {
      remainingCounterTime = (remainingCounterTime > 1000) ? (remainingCounterTime - 1000) : 0;
    }

    counterRan = true;
    vTaskSuspend(NULL);
  }
}

void alphabetTask(void* arg) {
  while (1) {
    Serial.print("[Alphabet Task] Char: ");
    Serial.println(currentChar);

    currentChar++;
    if (currentChar > 'Z') currentChar = 'A';

    if (remainingAlphabetTime > 0) {
      remainingAlphabetTime = (remainingAlphabetTime > 2000) ? (remainingAlphabetTime - 2000) : 0;
    }

    alphabetRan = true;
    vTaskSuspend(NULL);
  }
}

void scheduleTasks(void* arg) {
  while (1) {
    // If all have run, reset flags and remaining times
    if (ledRan && counterRan && alphabetRan) {
      remainingLedTime = ledTaskExecutionTime;
      remainingCounterTime = counterTaskExecutionTime;
      remainingAlphabetTime = alphabetTaskExecutionTime;

      ledRan = false;
      counterRan = false;
      alphabetRan = false;
    }

    TickType_t shortestTime = UINT32_MAX;
    TaskHandle_t nextTask = NULL;

    if (!ledRan && remainingLedTime > 0 && remainingLedTime < shortestTime) {
      shortestTime = remainingLedTime;
      nextTask = ledTaskHandle;
    }
    if (!counterRan && remainingCounterTime > 0 && remainingCounterTime < shortestTime) {
      shortestTime = remainingCounterTime;
      nextTask = counterTaskHandle;
    }
    if (!alphabetRan && remainingAlphabetTime > 0 && remainingAlphabetTime < shortestTime) {
      shortestTime = remainingAlphabetTime;
      nextTask = alphabetTaskHandle;
    }

    if (nextTask != NULL) {
      vTaskResume(nextTask);
      // Wait a short time to let task run, which suspends itself
      vTaskDelay(pdMS_TO_TICKS(100));
    } else {
      // If no task to run, delay a bit before next check
      vTaskDelay(pdMS_TO_TICKS(50));
    }
  }
}

void setup() {
  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);

  Serial.begin(115200);
  while (!Serial);

  Wire.begin(41, 40);

  lcdInit();

  xTaskCreatePinnedToCore(ledTask, "LED Task", 2048, NULL, 1, &ledTaskHandle, 0);
  xTaskCreatePinnedToCore(counterTask, "Counter Task", 4096, NULL, 1, &counterTaskHandle, 0);
  xTaskCreatePinnedToCore(alphabetTask, "Alphabet Task", 2048, NULL, 1, &alphabetTaskHandle, 0);
  xTaskCreatePinnedToCore(scheduleTasks, "Scheduler Task", 4096, NULL, 2, NULL, 0);

  // Suspend all tasks initially; scheduler will resume them as needed
  vTaskSuspend(ledTaskHandle);
  vTaskSuspend(counterTaskHandle);
  vTaskSuspend(alphabetTaskHandle);
}

void loop() {
  // Empty; scheduling done via tasks
}
